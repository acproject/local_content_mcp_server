name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  BUILD_TYPE: Release

jobs:
  # Build and test on multiple platforms
  build-and-test:
    name: Build and Test (${{ matrix.os }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ubuntu-latest, ubuntu-20.04, macos-latest]
        include:
          - os: ubuntu-latest
            deps_cmd: sudo apt-get update && sudo apt-get install -y cmake build-essential libsqlite3-dev
          - os: ubuntu-20.04
            deps_cmd: sudo apt-get update && sudo apt-get install -y cmake build-essential libsqlite3-dev
          - os: macos-latest
            deps_cmd: brew install cmake sqlite3

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: ${{ matrix.deps_cmd }}

    - name: Configure CMake
      run: |
        mkdir build
        cd build
        cmake .. -DCMAKE_BUILD_TYPE=${{ env.BUILD_TYPE }} -DBUILD_CLIENT=ON -DBUILD_TESTS=ON

    - name: Build
      run: |
        cd build
        make -j$(nproc 2>/dev/null || sysctl -n hw.ncpu)

    - name: Run tests
      run: |
        cd build
        ctest --output-on-failure

    - name: Test server startup
      run: |
        # Start server in background
        ./build/server/mcp_server --config config/server.json &
        SERVER_PID=$!
        
        # Wait for server to start
        sleep 5
        
        # Test health endpoint
        curl -f http://localhost:8080/health || exit 1
        
        # Stop server
        kill $SERVER_PID
        wait $SERVER_PID 2>/dev/null || true

    - name: Test client
      run: |
        # Start server in background
        ./build/server/mcp_server --config config/server.json &
        SERVER_PID=$!
        
        # Wait for server to start
        sleep 5
        
        # Test client commands
        ./build/client/mcp_client --help
        
        # Stop server
        kill $SERVER_PID
        wait $SERVER_PID 2>/dev/null || true

    - name: Upload build artifacts
      uses: actions/upload-artifact@v3
      if: matrix.os == 'ubuntu-latest'
      with:
        name: build-artifacts-${{ matrix.os }}
        path: |
          build/server/mcp_server
          build/client/mcp_client
        retention-days: 7

  # Code quality checks
  code-quality:
    name: Code Quality
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y clang-format cppcheck

    - name: Check code formatting
      run: |
        find server client -name '*.cpp' -o -name '*.hpp' | xargs clang-format --dry-run --Werror

    - name: Run static analysis
      run: |
        cppcheck --enable=all --std=c++17 --error-exitcode=1 server/ client/

  # Security scan
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        scan-type: 'fs'
        scan-ref: '.'
        format: 'sarif'
        output: 'trivy-results.sarif'

    - name: Upload Trivy scan results
      uses: github/codeql-action/upload-sarif@v2
      if: always()
      with:
        sarif_file: 'trivy-results.sarif'

  # Docker build and test
  docker:
    name: Docker Build
    runs-on: ubuntu-latest
    needs: build-and-test
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false
        tags: local-content-mcp:test
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Test Docker image
      run: |
        # Run container
        docker run -d --name test-container -p 8080:8080 local-content-mcp:test
        
        # Wait for container to start
        sleep 10
        
        # Test health endpoint
        curl -f http://localhost:8080/health
        
        # Check logs
        docker logs test-container
        
        # Stop container
        docker stop test-container
        docker rm test-container

    - name: Login to Docker Hub
      if: github.event_name == 'release'
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    - name: Build and push Docker image
      if: github.event_name == 'release'
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/local-content-mcp:latest
          ${{ secrets.DOCKER_USERNAME }}/local-content-mcp:${{ github.event.release.tag_name }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Create release artifacts
  release:
    name: Create Release
    runs-on: ubuntu-latest
    needs: [build-and-test, code-quality, docker]
    if: github.event_name == 'release'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Install dependencies
      run: |
        sudo apt-get update
        sudo apt-get install -y cmake build-essential libsqlite3-dev

    - name: Build release binaries
      run: |
        mkdir build
        cd build
        cmake .. -DCMAKE_BUILD_TYPE=Release -DBUILD_CLIENT=ON
        make -j$(nproc)

    - name: Create release package
      run: |
        mkdir -p release/local-content-mcp-${{ github.event.release.tag_name }}
        cp -r build/server/mcp_server release/local-content-mcp-${{ github.event.release.tag_name }}/
        cp -r build/client/mcp_client release/local-content-mcp-${{ github.event.release.tag_name }}/
        cp -r config/ release/local-content-mcp-${{ github.event.release.tag_name }}/
        cp -r scripts/ release/local-content-mcp-${{ github.event.release.tag_name }}/
        cp README.md LICENSE release/local-content-mcp-${{ github.event.release.tag_name }}/
        
        cd release
        tar -czf local-content-mcp-${{ github.event.release.tag_name }}-linux-x64.tar.gz local-content-mcp-${{ github.event.release.tag_name }}/

    - name: Upload release assets
      uses: actions/upload-release-asset@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        upload_url: ${{ github.event.release.upload_url }}
        asset_path: ./release/local-content-mcp-${{ github.event.release.tag_name }}-linux-x64.tar.gz
        asset_name: local-content-mcp-${{ github.event.release.tag_name }}-linux-x64.tar.gz
        asset_content_type: application/gzip

  # Deployment (example for staging)
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [build-and-test, docker]
    if: github.ref == 'refs/heads/develop'
    environment: staging
    
    steps:
    - name: Deploy to staging
      run: |
        echo "Deploying to staging environment..."
        # Add your deployment commands here
        # For example, using SSH to deploy to a staging server
        # ssh user@staging-server 'docker pull image && docker-compose up -d'

  # Deployment (example for production)
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-and-test, docker]
    if: github.event_name == 'release'
    environment: production
    
    steps:
    - name: Deploy to production
      run: |
        echo "Deploying to production environment..."
        # Add your deployment commands here
        # For example, using SSH to deploy to a production server
        # ssh user@production-server 'docker pull image && docker-compose up -d'